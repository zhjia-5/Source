# 构造函数的语法糖

## 传统的构造函数会出现以下问题
  1，属性和原型方法定义分离，降低了可读性
  2，原型成员被枚举
  3，默认情况下，构造函数任然可以被当作普通函数使用

## 类的特点
  1，类声明不会被提升，与let 和const 一样，存在暂时性死区。
  2，类的所有代码均在严格模式下执行。
  3，类的所有方法都是不可枚举的。
  4，类的所有方法都无法被当作构造函数使用。不能通过new得到的对象来调用
  5，类的构造器必须使用new 来调用。

## 类的其他书写方式
  1，可计算的成员名[name]:"zhangsan"
  2，getter 和 setter
      Object.defineProperty可定义某个对象成员属性的读取和设置(es5)
      使用getter和setter控制的属性不在原型上
  3，静态成员
      使用static修饰的成员为静态成员。
      只能该类调用，new 出来的对象不能调用
  4，字段初始化器（ES7）
      有些属性具有默认值，不需要借助任何参数。
      
    语法: class Test{     等同于：class Test{
              a=1;                  constructor(){
              b=2;                    this.a = 1;
          }                           this.b = 2;
                                    }
                                  }

  5，类表达式
    语法:
      const Test = class{
        a = 1;
        b = 2;
      }
      const test = new Test();

  6，类的继承

    如果两个类A和B，如果可以描述为B 是 A，则A 和 B 形成继承关系。
    如果 B 是 A，则
      得出结论：
        1，B继承自A
        2，A派生B
        3，B是A的子类
        4，A是B的父类 

    关键字：
          extends ：
            -继承，用于类的定义
           super  ：
           - 直接当作函数调用，表示父类构造函数
           - 如果当作对象使用，则表示父类的原型
           用法：在子类的方法中使用super.print()调用父类的方法（print为父类的方法）

    *** 注意 ***
      1,ES6要求，如果定义了constructor,并且该类是子类，
        则必须在constructor的第一行手动调用父类构造函数：使用super();
      2,如果子类不写constructor，则会有默认的构造器，该构造器参数和父类一直，
        并且自动调用父类构造器。
      3，如果子类有和父类同名的属性或方法，将覆盖父类的（不改变父类方法）
      4，
  